//SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.8.0;

import "./ILPool.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "./PoolToken.sol";

// **** There actually needs to be some sort of incentive if I want there to be a main token - whether this be in the form of liquidity tokens for them to redeem rewards from, maybe it will be required for voting ? maybe its value tracks the value of the treasury or the profits generated by the treasury ?
// **** What does AAVE's token actually do ? Maybe I can have it as an airdrop and an aditional minting reward which can be used for voting ?
// **** Perhaps stakers get occasionally rewarded with tokens proportional to the amount they deposited and the amount of time they staked for after a given amount of time
// **** Maybe this is not even necessary at all and it can just be a decentralized lending platform
// **** Maybe we should have our own DAO which is what the tokens can be used for, and some of the liquidity is transferred over to the DAO to be used to back and fund new projects and such

contract LPool is ILPool, AccessControl {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    mapping(address => address) private assetsPool;
    mapping(address => address) private poolAssets;
    address[] private approvedAssets;

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());
    }

    function approveAsset(address _token, string memory _ltName, string memory _ltSymbol) public override onlyRole(DEFAULT_ADMIN_ROLE) {
        require(!isApprovedAsset(_token), "This token has already been approved");
        address newFarmToken = address(new PoolToken(_ltName, _ltSymbol, 0)); 
        assetsPool[_token] = newFarmToken;
        poolAssets[newFarmToken] = _token;
        approvedAssets.push(_token);
    }

    function isApprovedAsset(address _token) public view override returns (bool _isApproved) {
        _isApproved = assetsPool[_token] != address(0);
    }

    function getApprovedAsset(address _token) public view override returns (address _approvedAsset) {
        require(isPoolToken(_token), "This asset is not a pool token");
        _approvedAsset = poolAssets[_token];
    }

    function getApprovedAssets() public view override returns (address[] memory _approvedAssets) {
        _approvedAssets = approvedAssets;
    }

    function isPoolToken(address _token) public view override returns (bool _isPool) {
        _isPool = poolAssets[_token] != address(0);
    }

    function getPoolToken(address _token) public view override returns (address _poolToken) {
        require(isApprovedAsset(_token), "This asset is not approved");
        _poolToken = assetsPool[_token];
    }

    function depositTokensReceived(address _token, uint256 _amount) public view override returns (uint256 _tokensReceived) {
        // Make sure that the token is approved
        require(isApprovedAsset(_token), "This asset is not approved");
        require(_amount > 0, "Deposit amount must be greater than 0");
        address _poolToken = getPoolToken(_token);

        // Calculate the compensation tokens, if the denominator is zero then it means there is 0 staked and there should be 0 tokens, therefore 
        uint256 numerator = _amount.mul(IERC20(_poolToken).totalSupply());
        uint256 denominator = IERC20(_token).balanceOf(address(this));

        if (numerator == 0 && denominator == 0) {
            _tokensReceived = _amount;
        } else {
            _tokensReceived = numerator.div(denominator.add(1)); // Add 1 to avoid division by zero errors
        }
    }

    function deposit(address _token, uint256 _amount) public override {
        // Make sure that the token is approved
        require(isApprovedAsset(_token), "This asset is not approved");
        require(_amount > 0, "Deposit amount must be greater than 0");
        address _poolToken = getPoolToken(_token);

        // Deposit to the pool and mint new pool tokens
        uint256 compensationTokens = depositTokensReceived(_token, _amount);
        require(compensationTokens > 0, "Tokens received is too low to allow the deposit");

        IERC20(_token).transferFrom(_msgSender(), address(this), _amount);
        PoolToken(_poolToken).mint(_msgSender(), compensationTokens);
        emit Deposit(_msgSender(), _token, _amount, _poolToken, compensationTokens);
    }

    function withdrawTokensReceived(address _token, uint256 _amount) public view override returns (uint256 _tokensReceived) {
        // Make sure that the token is approved
        require(isPoolToken(_token), "This token is not a pool token");
        require(_amount > 0, "Withdraw amount must be greater than 0");
        address approvedAsset = getApprovedAsset(_token);

        // Calculate the withdraw amount
        uint256 numerator = _amount.mul(IERC20(approvedAsset).totalSupply());
        uint256 denominator = IERC20(_token).totalSupply();
        _tokensReceived = numerator.div(denominator.add(1)); // Add one to prevent division by 0 errors
    }

    function withdraw(address _token, uint256 _amount) public override {
        // Make sure that the token is approved
        require(isPoolToken(_token), "This token is not a pool token");
        require(_amount > 0, "Withdraw amount must be greater than 0");
        address approvedAsset = getApprovedAsset(_token);

        // Burn the pool tokens and withdraw tokens to the user
        uint256 withdrawAmount = withdrawTokensReceived(_token, _amount);
        require(withdrawAmount > 0, "The amount of tokens withdrawn is too low");

        PoolToken(_token).burn(_msgSender(), _amount);
        IERC20(approvedAsset).transfer(_msgSender(), withdrawAmount);
        emit Withdraw(_msgSender(), approvedAsset, withdrawAmount, _token, _amount);
    }

    // Borrows assets from the pool to be used in another account
    function lend(address _token, uint256 _amount, address _to) public override onlyRole(DEFAULT_ADMIN_ROLE) {
        // Make sure the asset to be loaned is a backed asset
        require(isApprovedAsset(_token), "Only approved assets may be lended");
        require(_amount > 0, "Lended amount must be greater than 0");

        // Lend the tokens
        IERC20(_token).transfer(_to, _amount);
        emit Lend(_token, _amount, _to);
    }
}